#!/usr/bin/env python3
"""
🔍 Vulnerability Scanner для Anonymeme API
Automated security assessment и vulnerability detection
"""

import asyncio
import aiohttp
import json
import re
import time
import logging
import hashlib
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime
from urllib.parse import urljoin, urlparse
import yaml

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Vulnerability finding"""
    id: str
    severity: str  # critical, high, medium, low, info
    title: str
    description: str
    endpoint: str
    method: str
    parameter: Optional[str] = None
    payload: Optional[str] = None
    evidence: Optional[str] = None
    remediation: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    timestamp: datetime = field(default_factory=datetime.utcnow)


@dataclass
class ScanResult:
    """Scan result summary"""
    scan_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    total_requests: int = 0
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    
    @property
    def duration(self) -> float:
        if self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0
    
    @property
    def severity_counts(self) -> Dict[str, int]:
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        for vuln in self.vulnerabilities:
            counts[vuln.severity] += 1
        return counts


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner для API endpoints
    """
    
    def __init__(self, base_url: str, auth_token: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.auth_token = auth_token
        self.session: Optional[aiohttp.ClientSession] = None
        
        # Scan configurations
        self.timeout = aiohttp.ClientTimeout(total=30)
        self.max_concurrent = 10
        self.scan_result = ScanResult(
            scan_id=hashlib.md5(f"{base_url}-{time.time()}".encode()).hexdigest()[:8],
            start_time=datetime.utcnow()
        )
        
        # Payloads для различных типов уязвимостей
        self.payloads = self._load_payloads()
        
        # Endpoints для сканирования
        self.endpoints = [
            # Authentication endpoints
            {'path': '/api/v1/auth/login', 'method': 'POST'},
            {'path': '/api/v1/auth/register', 'method': 'POST'},
            {'path': '/api/v1/auth/refresh', 'method': 'POST'},
            {'path': '/api/v1/auth/logout', 'method': 'POST'},
            
            # User endpoints
            {'path': '/api/v1/users/profile', 'method': 'GET'},
            {'path': '/api/v1/users/profile', 'method': 'PUT'},
            
            # Trading endpoints
            {'path': '/api/v1/trading/buy', 'method': 'POST'},
            {'path': '/api/v1/trading/sell', 'method': 'POST'},
            {'path': '/api/v1/trading/history', 'method': 'GET'},
            
            # Token endpoints
            {'path': '/api/v1/tokens', 'method': 'GET'},
            {'path': '/api/v1/tokens/create', 'method': 'POST'},
            {'path': '/api/v1/tokens/{token_id}', 'method': 'GET'},
            
            # Admin endpoints
            {'path': '/api/v1/admin/users', 'method': 'GET'},
            {'path': '/api/v1/admin/stats', 'method': 'GET'},
            {'path': '/api/v1/admin/tokens', 'method': 'GET'},
            
            # Analytics endpoints
            {'path': '/api/v1/analytics/tokens', 'method': 'GET'},
            {'path': '/api/v1/analytics/trading', 'method': 'GET'},
            
            # Health и system endpoints
            {'path': '/health', 'method': 'GET'},
            {'path': '/metrics', 'method': 'GET'},
            {'path': '/docs', 'method': 'GET'},
            {'path': '/redoc', 'method': 'GET'},
        ]
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load vulnerability testing payloads"""
        return {
            'sql_injection': [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR '1'='1' /*",
                "') OR ('1'='1",
                "' UNION SELECT 1,2,3--",
                "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                "1'; DROP TABLE users; --",
                "1' OR SLEEP(5)--",
                "' OR 1=1#",
                "admin'--",
                "admin' /*"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "'><script>alert('XSS')</script>",
                "\"><script>alert('XSS')</script>",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "<marquee onstart=alert('XSS')>XSS</marquee>"
            ],
            'command_injection': [
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "&& cat /etc/passwd",
                "; ls -la",
                "| ls -la",
                "&& ls -la",
                "; whoami",
                "| whoami",
                "&& whoami",
                "`cat /etc/passwd`",
                "$(cat /etc/passwd)"
            ],
            'path_traversal': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "..%252f..%252f..%252fetc%252fpasswd",
                "....\\\\....\\\\....\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts"
            ],
            'nosql_injection': [
                '{"$ne": null}',
                '{"$gt": ""}',
                '{"$where": "this.username == this.password"}',
                '{"$regex": ".*"}',
                '{"username": {"$ne": null}, "password": {"$ne": null}}',
                '{"$or": [{"username": "admin"}, {"username": "administrator"}]}'
            ],
            'ldap_injection': [
                '*',
                '*)(&',
                '*))%00',
                '*()|%26',
                '*()|&',
                '*()(|&)',
                '*)(uid=*',
                '*)((|uid=*'
            ],
            'header_injection': [
                "test\r\nX-Injected-Header: injected",
                "test\nX-Injected-Header: injected",
                "test\r\n\r\n<script>alert('XSS')</script>",
                "test%0d%0aX-Injected-Header:%20injected",
                "test%0aX-Injected-Header:%20injected"
            ]
        }
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    async def scan_all(self) -> ScanResult:
        """Perform comprehensive vulnerability scan"""
        logger.info(f"Starting vulnerability scan for {self.base_url}")
        
        try:
            # 1. Information gathering
            await self._information_gathering()
            
            # 2. Authentication bypass tests
            await self._test_authentication_bypass()
            
            # 3. Authorization tests
            await self._test_authorization_flaws()
            
            # 4. Input validation tests
            await self._test_input_validation()
            
            # 5. Session management tests
            await self._test_session_management()
            
            # 6. Security headers tests
            await self._test_security_headers()
            
            # 7. SSL/TLS tests
            await self._test_ssl_configuration()
            
            # 8. Rate limiting tests
            await self._test_rate_limiting()
            
            # 9. Error handling tests
            await self._test_error_handling()
            
            # 10. API-specific tests
            await self._test_api_specific_vulnerabilities()
            
        except Exception as e:
            self.scan_result.errors.append(f"Scan error: {str(e)}")
            logger.error(f"Scan error: {e}")
        
        finally:
            self.scan_result.end_time = datetime.utcnow()
            logger.info(f"Vulnerability scan completed in {self.scan_result.duration:.2f} seconds")
            logger.info(f"Found {len(self.scan_result.vulnerabilities)} vulnerabilities")
        
        return self.scan_result
    
    async def _information_gathering(self):
        """Gather information about the target"""
        logger.info("Performing information gathering...")
        
        # Test common disclosure endpoints
        disclosure_endpoints = [
            '/.env',
            '/config.json',
            '/swagger.json',
            '/api/docs',
            '/debug',
            '/server-status',
            '/health',
            '/metrics',
            '/info'
        ]
        
        for endpoint in disclosure_endpoints:
            await self._test_information_disclosure(endpoint)
    
    async def _test_information_disclosure(self, endpoint: str):
        """Test for information disclosure"""
        url = urljoin(self.base_url, endpoint)
        
        try:
            async with self.session.get(url) as response:
                self.scan_result.total_requests += 1
                
                if response.status == 200:
                    content = await response.text()
                    
                    # Check for sensitive information patterns
                    sensitive_patterns = [
                        r'password\s*[:=]\s*["\']?[^"\'\s]+',
                        r'secret\s*[:=]\s*["\']?[^"\'\s]+',
                        r'api[_-]?key\s*[:=]\s*["\']?[^"\'\s]+',
                        r'database\s*[:=]\s*["\']?[^"\'\s]+',
                        r'private[_-]?key',
                        r'-----BEGIN [A-Z]+ KEY-----'
                    ]
                    
                    for pattern in sensitive_patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            self._add_vulnerability(
                                'info_disclosure',
                                'medium',
                                'Information Disclosure',
                                f'Sensitive information exposed at {endpoint}',
                                endpoint,
                                'GET',
                                evidence=f'Pattern found: {pattern}'
                            )
                            break
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing {endpoint}: {str(e)}")
    
    async def _test_authentication_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        logger.info("Testing authentication bypass...")
        
        # Test SQL injection in login
        login_endpoint = '/api/v1/auth/login'
        
        for payload in self.payloads['sql_injection']:
            data = {
                'username': payload,
                'password': 'test'
            }
            
            await self._test_payload(login_endpoint, 'POST', data, 'sql_injection')
            
            # Also test password field
            data = {
                'username': 'admin',
                'password': payload
            }
            
            await self._test_payload(login_endpoint, 'POST', data, 'sql_injection')
    
    async def _test_authorization_flaws(self):
        """Test for authorization vulnerabilities"""
        logger.info("Testing authorization flaws...")
        
        # Test accessing admin endpoints without authorization
        admin_endpoints = [ep for ep in self.endpoints if '/admin/' in ep['path']]
        
        for endpoint in admin_endpoints:
            await self._test_unauthorized_access(endpoint['path'], endpoint['method'])
    
    async def _test_unauthorized_access(self, path: str, method: str):
        """Test unauthorized access to protected endpoints"""
        url = urljoin(self.base_url, path)
        
        try:
            # Test without authentication
            if method == 'GET':
                async with self.session.get(url) as response:
                    self.scan_result.total_requests += 1
                    
                    if response.status == 200:
                        self._add_vulnerability(
                            'broken_auth',
                            'high',
                            'Broken Authentication',
                            f'Admin endpoint accessible without authentication',
                            path,
                            method,
                            remediation='Implement proper authentication checks'
                        )
            
            # Test with invalid token
            headers = {'Authorization': 'Bearer invalid_token'}
            if method == 'GET':
                async with self.session.get(url, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    
                    if response.status == 200:
                        self._add_vulnerability(
                            'broken_auth',
                            'high',
                            'Broken Authentication',
                            f'Admin endpoint accepts invalid token',
                            path,
                            method,
                            remediation='Validate authentication tokens properly'
                        )
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing {path}: {str(e)}")
    
    async def _test_input_validation(self):
        """Test input validation vulnerabilities"""
        logger.info("Testing input validation...")
        
        # Test all POST/PUT endpoints
        test_endpoints = [ep for ep in self.endpoints if ep['method'] in ['POST', 'PUT']]
        
        for endpoint in test_endpoints:
            await self._test_injection_vulnerabilities(endpoint['path'], endpoint['method'])
    
    async def _test_injection_vulnerabilities(self, path: str, method: str):
        """Test various injection vulnerabilities"""
        test_parameters = ['id', 'username', 'email', 'token_address', 'amount', 'search', 'filter']
        
        for param in test_parameters:
            # SQL Injection
            for payload in self.payloads['sql_injection'][:5]:  # Test first 5 payloads
                data = {param: payload}
                await self._test_payload(path, method, data, 'sql_injection', param)
            
            # XSS
            for payload in self.payloads['xss'][:3]:  # Test first 3 payloads
                data = {param: payload}
                await self._test_payload(path, method, data, 'xss', param)
            
            # Command Injection
            for payload in self.payloads['command_injection'][:3]:
                data = {param: payload}
                await self._test_payload(path, method, data, 'command_injection', param)
    
    async def _test_payload(self, path: str, method: str, data: Dict, 
                          vulnerability_type: str, parameter: str = None):
        """Test a specific payload against an endpoint"""
        url = urljoin(self.base_url, path)
        
        try:
            headers = {}
            if self.auth_token:
                headers['Authorization'] = f'Bearer {self.auth_token}'
            
            if method == 'POST':
                async with self.session.post(url, json=data, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    await self._analyze_response(response, vulnerability_type, path, method, data, parameter)
            
            elif method == 'PUT':
                async with self.session.put(url, json=data, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    await self._analyze_response(response, vulnerability_type, path, method, data, parameter)
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing {path} with {vulnerability_type}: {str(e)}")
    
    async def _analyze_response(self, response, vulnerability_type: str, path: str, 
                              method: str, payload: Dict, parameter: str = None):
        """Analyze response for vulnerability indicators"""
        content = await response.text()
        
        # SQL Injection indicators
        if vulnerability_type == 'sql_injection':
            sql_errors = [
                'sql syntax', 'mysql', 'postgresql', 'sqlite', 'oracle',
                'syntax error', 'database error', 'invalid query',
                'pg_query', 'mysql_query', 'sqlite3_query'
            ]
            
            for error in sql_errors:
                if error.lower() in content.lower():
                    self._add_vulnerability(
                        'sql_injection',
                        'high',
                        'SQL Injection',
                        f'SQL injection vulnerability detected via error message',
                        path,
                        method,
                        parameter=parameter,
                        payload=str(payload),
                        evidence=f'Error message contains: {error}',
                        cwe_id='CWE-89'
                    )
                    return
            
            # Time-based SQL injection (check response time)
            if response.headers.get('server-timing'):
                # If response took significantly longer, might be time-based SQLi
                pass
        
        # XSS indicators
        elif vulnerability_type == 'xss':
            if response.status == 200:
                payload_value = list(payload.values())[0] if payload else ''
                if payload_value in content and '<script>' in payload_value:
                    self._add_vulnerability(
                        'xss',
                        'medium',
                        'Cross-Site Scripting (XSS)',
                        f'XSS vulnerability detected - payload reflected in response',
                        path,
                        method,
                        parameter=parameter,
                        payload=str(payload),
                        evidence='Script payload reflected in response',
                        cwe_id='CWE-79'
                    )
        
        # Command injection indicators
        elif vulnerability_type == 'command_injection':
            command_outputs = [
                'root:', 'bin:', 'daemon:', '/etc/passwd',
                'total', 'drwx', # ls output
                'uid=', 'gid=', # whoami output
            ]
            
            for output in command_outputs:
                if output in content:
                    self._add_vulnerability(
                        'command_injection',
                        'critical',
                        'Command Injection',
                        f'Command injection vulnerability detected',
                        path,
                        method,
                        parameter=parameter,
                        payload=str(payload),
                        evidence=f'Command output detected: {output}',
                        cwe_id='CWE-78'
                    )
                    return
    
    async def _test_session_management(self):
        """Test session management vulnerabilities"""
        logger.info("Testing session management...")
        
        # Test session fixation
        await self._test_session_fixation()
        
        # Test concurrent sessions
        await self._test_concurrent_sessions()
    
    async def _test_session_fixation(self):
        """Test for session fixation vulnerability"""
        # This would require implementing session-based authentication
        # For JWT-based systems, this test may not be applicable
        pass
    
    async def _test_concurrent_sessions(self):
        """Test concurrent session handling"""
        # Test if multiple sessions can be active simultaneously
        pass
    
    async def _test_security_headers(self):
        """Test security headers implementation"""
        logger.info("Testing security headers...")
        
        url = urljoin(self.base_url, '/')
        
        try:
            async with self.session.get(url) as response:
                self.scan_result.total_requests += 1
                headers = response.headers
                
                # Check for missing security headers
                required_headers = {
                    'X-Content-Type-Options': 'nosniff',
                    'X-Frame-Options': 'DENY',
                    'X-XSS-Protection': '1',
                    'Strict-Transport-Security': 'max-age',
                    'Content-Security-Policy': 'default-src'
                }
                
                for header, expected in required_headers.items():
                    if header not in headers:
                        self._add_vulnerability(
                            'missing_headers',
                            'low',
                            f'Missing Security Header: {header}',
                            f'Security header {header} is not implemented',
                            '/',
                            'GET',
                            remediation=f'Add {header} header with appropriate value'
                        )
                    elif expected not in headers[header]:
                        self._add_vulnerability(
                            'weak_headers',
                            'low',
                            f'Weak Security Header: {header}',
                            f'Security header {header} has weak configuration',
                            '/',
                            'GET',
                            evidence=f'Current value: {headers[header]}',
                            remediation=f'Strengthen {header} header configuration'
                        )
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing security headers: {str(e)}")
    
    async def _test_ssl_configuration(self):
        """Test SSL/TLS configuration"""
        logger.info("Testing SSL configuration...")
        
        if not self.base_url.startswith('https://'):
            self._add_vulnerability(
                'no_ssl',
                'medium',
                'No SSL/TLS Encryption',
                'Application does not use SSL/TLS encryption',
                '/',
                'GET',
                remediation='Implement SSL/TLS encryption'
            )
    
    async def _test_rate_limiting(self):
        """Test rate limiting implementation"""
        logger.info("Testing rate limiting...")
        
        # Test rapid requests to see if rate limiting is implemented
        test_url = urljoin(self.base_url, '/api/v1/tokens')
        
        try:
            # Send multiple rapid requests
            tasks = []
            for i in range(20):
                task = self.session.get(test_url)
                tasks.append(task)
            
            responses = await asyncio.gather(*tasks, return_exceptions=True)
            self.scan_result.total_requests += len(responses)
            
            # Check if any requests were rate limited (429 status)
            rate_limited = any(
                hasattr(r, 'status') and r.status == 429 
                for r in responses 
                if not isinstance(r, Exception)
            )
            
            if not rate_limited:
                self._add_vulnerability(
                    'no_rate_limiting',
                    'medium',
                    'Missing Rate Limiting',
                    'No rate limiting detected on API endpoints',
                    '/api/v1/tokens',
                    'GET',
                    remediation='Implement rate limiting to prevent abuse'
                )
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing rate limiting: {str(e)}")
    
    async def _test_error_handling(self):
        """Test error handling for information disclosure"""
        logger.info("Testing error handling...")
        
        # Test with malformed requests
        test_cases = [
            {'path': '/api/v1/tokens/invalid_id', 'method': 'GET'},
            {'path': '/api/v1/nonexistent', 'method': 'GET'},
            {'path': '/api/v1/trading/buy', 'method': 'POST', 'data': 'invalid_json'},
        ]
        
        for case in test_cases:
            await self._test_error_response(case)
    
    async def _test_error_response(self, test_case: Dict):
        """Test specific error response"""
        url = urljoin(self.base_url, test_case['path'])
        
        try:
            if test_case['method'] == 'GET':
                async with self.session.get(url) as response:
                    self.scan_result.total_requests += 1
                    await self._check_error_disclosure(response, test_case['path'])
            
            elif test_case['method'] == 'POST':
                data = test_case.get('data', {})
                if data == 'invalid_json':
                    # Send invalid JSON
                    headers = {'Content-Type': 'application/json'}
                    async with self.session.post(url, data='invalid{json', headers=headers) as response:
                        self.scan_result.total_requests += 1
                        await self._check_error_disclosure(response, test_case['path'])
        
        except Exception as e:
            self.scan_result.errors.append(f"Error testing error handling: {str(e)}")
    
    async def _check_error_disclosure(self, response, path: str):
        """Check error response for information disclosure"""
        if response.status >= 500:
            content = await response.text()
            
            # Check for stack traces or sensitive information
            disclosure_patterns = [
                r'Traceback \(most recent call last\)',
                r'File ".*", line \d+',
                r'Exception in thread',
                r'/home/\w+/',
                r'/var/www/',
                r'Database connection failed',
                r'Internal server error.*:\s*.*'
            ]
            
            for pattern in disclosure_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    self._add_vulnerability(
                        'error_disclosure',
                        'low',
                        'Information Disclosure in Error Messages',
                        'Error messages expose sensitive system information',
                        path,
                        'GET',
                        evidence=f'Pattern found: {pattern}',
                        remediation='Implement generic error messages for production'
                    )
                    break
    
    async def _test_api_specific_vulnerabilities(self):
        """Test API-specific vulnerabilities"""
        logger.info("Testing API-specific vulnerabilities...")
        
        # Test BOLA (Broken Object Level Authorization)
        await self._test_bola()
        
        # Test BFLA (Broken Function Level Authorization)
        await self._test_bfla()
        
        # Test Mass Assignment
        await self._test_mass_assignment()
    
    async def _test_bola(self):
        """Test Broken Object Level Authorization"""
        # Test accessing resources with different IDs
        test_endpoints = [
            '/api/v1/users/1',
            '/api/v1/users/999',
            '/api/v1/tokens/1',
            '/api/v1/tokens/999',
        ]
        
        for endpoint in test_endpoints:
            url = urljoin(self.base_url, endpoint)
            
            try:
                headers = {}
                if self.auth_token:
                    headers['Authorization'] = f'Bearer {self.auth_token}'
                
                async with self.session.get(url, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    
                    if response.status == 200:
                        # This might indicate BOLA if user can access other users' data
                        content = await response.text()
                        if '"id"' in content and '"user' in content.lower():
                            self._add_vulnerability(
                                'bola',
                                'high',
                                'Broken Object Level Authorization (BOLA)',
                                f'User can access other users\' data at {endpoint}',
                                endpoint,
                                'GET',
                                remediation='Implement proper object-level authorization checks',
                                cwe_id='CWE-639'
                            )
            
            except Exception as e:
                self.scan_result.errors.append(f"Error testing BOLA {endpoint}: {str(e)}")
    
    async def _test_bfla(self):
        """Test Broken Function Level Authorization"""
        # Test admin functions with regular user token
        admin_endpoints = [
            '/api/v1/admin/users',
            '/api/v1/admin/stats',
            '/api/v1/admin/tokens',
        ]
        
        for endpoint in admin_endpoints:
            url = urljoin(self.base_url, endpoint)
            
            try:
                # Test with regular user token (if available)
                headers = {}
                if self.auth_token:
                    headers['Authorization'] = f'Bearer {self.auth_token}'
                
                async with self.session.get(url, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    
                    if response.status == 200:
                        self._add_vulnerability(
                            'bfla',
                            'high',
                            'Broken Function Level Authorization (BFLA)',
                            f'Regular user can access admin function: {endpoint}',
                            endpoint,
                            'GET',
                            remediation='Implement proper function-level authorization',
                            cwe_id='CWE-285'
                        )
            
            except Exception as e:
                self.scan_result.errors.append(f"Error testing BFLA {endpoint}: {str(e)}")
    
    async def _test_mass_assignment(self):
        """Test Mass Assignment vulnerabilities"""
        # Test adding unexpected parameters to requests
        test_data = {
            'username': 'testuser',
            'email': 'test@example.com',
            'role': 'admin',  # Should not be assignable
            'is_admin': True,  # Should not be assignable
            'balance': 1000000,  # Should not be assignable
        }
        
        endpoints_to_test = [
            '/api/v1/users/profile',
            '/api/v1/auth/register'
        ]
        
        for endpoint in endpoints_to_test:
            url = urljoin(self.base_url, endpoint)
            
            try:
                headers = {}
                if self.auth_token:
                    headers['Authorization'] = f'Bearer {self.auth_token}'
                
                async with self.session.put(url, json=test_data, headers=headers) as response:
                    self.scan_result.total_requests += 1
                    
                    if response.status in [200, 201]:
                        content = await response.text()
                        
                        # Check if sensitive fields were updated
                        if '"role":"admin"' in content or '"is_admin":true' in content:
                            self._add_vulnerability(
                                'mass_assignment',
                                'high',
                                'Mass Assignment',
                                f'Mass assignment vulnerability allows privilege escalation',
                                endpoint,
                                'PUT',
                                evidence='Sensitive fields can be mass assigned',
                                remediation='Implement field whitelisting for mass assignment',
                                cwe_id='CWE-915'
                            )
            
            except Exception as e:
                self.scan_result.errors.append(f"Error testing mass assignment {endpoint}: {str(e)}")
    
    def _add_vulnerability(self, vuln_id: str, severity: str, title: str, 
                          description: str, endpoint: str, method: str,
                          parameter: str = None, payload: str = None,
                          evidence: str = None, remediation: str = None,
                          cwe_id: str = None, cvss_score: float = None):
        """Add vulnerability to scan results"""
        vulnerability = Vulnerability(
            id=vuln_id,
            severity=severity,
            title=title,
            description=description,
            endpoint=endpoint,
            method=method,
            parameter=parameter,
            payload=payload,
            evidence=evidence,
            remediation=remediation,
            cwe_id=cwe_id,
            cvss_score=cvss_score
        )
        
        self.scan_result.vulnerabilities.append(vulnerability)
        logger.warning(f"Vulnerability found: {title} at {endpoint}")
    
    def generate_report(self, format: str = 'json') -> str:
        """Generate scan report in specified format"""
        if format == 'json':
            return self._generate_json_report()
        elif format == 'html':
            return self._generate_html_report()
        elif format == 'csv':
            return self._generate_csv_report()
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _generate_json_report(self) -> str:
        """Generate JSON format report"""
        report = {
            'scan_metadata': {
                'scan_id': self.scan_result.scan_id,
                'target': self.base_url,
                'start_time': self.scan_result.start_time.isoformat(),
                'end_time': self.scan_result.end_time.isoformat() if self.scan_result.end_time else None,
                'duration_seconds': self.scan_result.duration,
                'total_requests': self.scan_result.total_requests
            },
            'summary': {
                'total_vulnerabilities': len(self.scan_result.vulnerabilities),
                'severity_breakdown': self.scan_result.severity_counts,
                'errors': self.scan_result.errors
            },
            'vulnerabilities': []
        }
        
        for vuln in self.scan_result.vulnerabilities:
            vuln_dict = {
                'id': vuln.id,
                'severity': vuln.severity,
                'title': vuln.title,
                'description': vuln.description,
                'endpoint': vuln.endpoint,
                'method': vuln.method,
                'parameter': vuln.parameter,
                'payload': vuln.payload,
                'evidence': vuln.evidence,
                'remediation': vuln.remediation,
                'cwe_id': vuln.cwe_id,
                'cvss_score': vuln.cvss_score,
                'timestamp': vuln.timestamp.isoformat()
            }
            report['vulnerabilities'].append(vuln_dict)
        
        return json.dumps(report, indent=2)
    
    def _generate_html_report(self) -> str:
        """Generate HTML format report"""
        severity_colors = {
            'critical': '#dc3545',
            'high': '#fd7e14',
            'medium': '#ffc107',
            'low': '#28a745',
            'info': '#17a2b8'
        }
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Security Scan Report - {self.base_url}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .summary {{ margin: 20px 0; }}
                .vulnerability {{ margin: 15px 0; padding: 15px; border-left: 4px solid; border-radius: 3px; }}
                .critical {{ border-color: {severity_colors['critical']}; background: #f8d7da; }}
                .high {{ border-color: {severity_colors['high']}; background: #fde2e4; }}
                .medium {{ border-color: {severity_colors['medium']}; background: #fff3cd; }}
                .low {{ border-color: {severity_colors['low']}; background: #d4edda; }}
                .info {{ border-color: {severity_colors['info']}; background: #cce7f0; }}
                .code {{ background: #f8f9fa; padding: 5px; border-radius: 3px; font-family: monospace; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Security Scan Report</h1>
                <p><strong>Target:</strong> {self.base_url}</p>
                <p><strong>Scan ID:</strong> {self.scan_result.scan_id}</p>
                <p><strong>Duration:</strong> {self.scan_result.duration:.2f} seconds</p>
                <p><strong>Total Requests:</strong> {self.scan_result.total_requests}</p>
            </div>
            
            <div class="summary">
                <h2>Summary</h2>
                <p><strong>Total Vulnerabilities:</strong> {len(self.scan_result.vulnerabilities)}</p>
                <ul>
        """
        
        for severity, count in self.scan_result.severity_counts.items():
            if count > 0:
                html += f'<li><span style="color: {severity_colors[severity]};">{severity.title()}</span>: {count}</li>'
        
        html += """
                </ul>
            </div>
            
            <div class="vulnerabilities">
                <h2>Vulnerabilities</h2>
        """
        
        for vuln in sorted(self.scan_result.vulnerabilities, 
                          key=lambda x: ['critical', 'high', 'medium', 'low', 'info'].index(x.severity)):
            html += f"""
                <div class="vulnerability {vuln.severity}">
                    <h3>{vuln.title}</h3>
                    <p><strong>Severity:</strong> {vuln.severity.title()}</p>
                    <p><strong>Endpoint:</strong> <span class="code">{vuln.method} {vuln.endpoint}</span></p>
                    <p><strong>Description:</strong> {vuln.description}</p>
            """
            
            if vuln.parameter:
                html += f'<p><strong>Parameter:</strong> <span class="code">{vuln.parameter}</span></p>'
            if vuln.payload:
                html += f'<p><strong>Payload:</strong> <span class="code">{vuln.payload}</span></p>'
            if vuln.evidence:
                html += f'<p><strong>Evidence:</strong> {vuln.evidence}</p>'
            if vuln.remediation:
                html += f'<p><strong>Remediation:</strong> {vuln.remediation}</p>'
            if vuln.cwe_id:
                html += f'<p><strong>CWE:</strong> {vuln.cwe_id}</p>'
            
            html += '</div>'
        
        html += """
            </div>
        </body>
        </html>
        """
        
        return html
    
    def _generate_csv_report(self) -> str:
        """Generate CSV format report"""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Header
        writer.writerow([
            'Vulnerability ID', 'Severity', 'Title', 'Description',
            'Endpoint', 'Method', 'Parameter', 'Payload',
            'Evidence', 'Remediation', 'CWE ID', 'CVSS Score', 'Timestamp'
        ])
        
        # Vulnerabilities
        for vuln in self.scan_result.vulnerabilities:
            writer.writerow([
                vuln.id, vuln.severity, vuln.title, vuln.description,
                vuln.endpoint, vuln.method, vuln.parameter, vuln.payload,
                vuln.evidence, vuln.remediation, vuln.cwe_id, vuln.cvss_score,
                vuln.timestamp.isoformat()
            ])
        
        return output.getvalue()


# Example usage and CLI interface
async def main():
    """Example usage of the vulnerability scanner"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Anonymeme API Vulnerability Scanner')
    parser.add_argument('--url', required=True, help='Base URL to scan')
    parser.add_argument('--token', help='Authentication token')
    parser.add_argument('--format', choices=['json', 'html', 'csv'], default='json', help='Report format')
    parser.add_argument('--output', help='Output file (default: stdout)')
    
    args = parser.parse_args()
    
    async with VulnerabilityScanner(args.url, args.token) as scanner:
        result = await scanner.scan_all()
        report = scanner.generate_report(args.format)
        
        if args.output:
            with open(args.output, 'w') as f:
                f.write(report)
            print(f"Report saved to {args.output}")
        else:
            print(report)


if __name__ == '__main__':
    asyncio.run(main())