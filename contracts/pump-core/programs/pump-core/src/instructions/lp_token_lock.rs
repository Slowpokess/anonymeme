/*!
üîí LP Token Lock - –ú–µ—Ö–∞–Ω–∏–∑–º –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ —Å —Ç–∞–π–º–ª–æ–∫–æ–º

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Ä–µ–∞–ª–∏–∑—É–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω—É—é –±–ª–æ–∫–∏—Ä–æ–≤–∫—É LP (Liquidity Provider) —Ç–æ–∫–µ–Ω–æ–≤
–¥–ª—è –∑–∞—â–∏—Ç—ã –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤ –æ—Ç rug pulls –∏ –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏.

## –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:

1. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞** - LP —Ç–æ–∫–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –±–ª–æ–∫–∏—Ä—É—é—Ç—Å—è –ø—Ä–∏ –≥—Ä–∞–¥–∞—Ü–∏–∏ –Ω–∞ DEX
2. **–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–π –ø–µ—Ä–∏–æ–¥** - –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –æ—Ç 1 –¥–Ω—è –¥–æ 365 –¥–Ω–µ–π
3. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ** - LP —Ç–æ–∫–µ–Ω—ã —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ PDA –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—ã
4. **–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏** - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–º–æ–∂–Ω–∞ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Å—Ä–æ–∫–∞
5. **–ß–∞—Å—Ç–∏—á–Ω–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞** - –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —á–∞—Å—Ç—è–º–∏ (vesting)
6. **–ü—Ä–æ–¥–ª–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏** - –°–æ–∑–¥–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –ø—Ä–æ–¥–ª–∏—Ç—å —Å—Ä–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏

## –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:

- ‚úÖ LP —Ç–æ–∫–µ–Ω—ã —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ PDA (Program Derived Address)
- ‚úÖ –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å–ª–µ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Å—Ä–æ–∫–∞
- ‚úÖ –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±–æ–π—Ç–∏ —Ç–∞–π–º–ª–æ–∫
- ‚úÖ Checked arithmetic –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
- ‚úÖ Events –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

## –§–æ—Ä–º—É–ª–∞ vesting (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ):

–ü—Ä–∏ –≤–∫–ª—é—á–µ–Ω–Ω–æ–º vesting —Ç–æ–∫–µ–Ω—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É—é—Ç—Å—è –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ:
```
unlockable_amount = total_locked * (current_time - lock_start) / lock_duration
```

*/

use anchor_lang::prelude::*;
use anchor_spl::{
    token::{self, Token, TokenAccount, Transfer, Mint},
    associated_token::AssociatedToken,
};

use crate::state::*;
use crate::errors::ErrorCode;

/// –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (1 –¥–µ–Ω—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
pub const MIN_LOCK_DURATION: i64 = 86_400; // 24 * 60 * 60

/// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ (365 –¥–Ω–µ–π –≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
pub const MAX_LOCK_DURATION: i64 = 31_536_000; // 365 * 24 * 60 * 60

/// –ö–æ–Ω—Ç–µ–∫—Å—Ç—ã –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ LP —Ç–æ–∫–µ–Ω–æ–≤
#[derive(Accounts)]
#[instruction(lock_duration: i64)]
pub struct LockLpTokens<'info> {
    /// –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ LP —Ç–æ–∫–µ–Ω–æ–≤ (—Å–æ–∑–¥–∞–µ—Ç—Å—è)
    #[account(
        init,
        payer = owner,
        space = LpTokenLock::ACCOUNT_SIZE,
        seeds = [LpTokenLock::SEED.as_bytes(), lp_mint.key().as_ref(), owner.key().as_ref()],
        bump
    )]
    pub lp_lock: Account<'info, LpTokenLock>,

    /// Mint LP —Ç–æ–∫–µ–Ω–æ–≤ (—Å–æ–∑–¥–∞–Ω–Ω—ã–π –ø—Ä–∏ –≥—Ä–∞–¥–∞—Ü–∏–∏ –Ω–∞ DEX)
    pub lp_mint: Account<'info, Mint>,

    /// –¢–æ–∫–µ–Ω –º–µ–º–∫–æ–∏–Ω–∞ (–¥–ª—è —Å–≤—è–∑–∏ —Å –≥—Ä–∞–¥–∞—Ü–∏–µ–π)
    pub token_mint: Account<'info, Mint>,

    /// –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–∏—Å—Ç–∏–Ω–≥–µ –Ω–∞ DEX
    #[account(
        seeds = [DexListing::SEED.as_bytes(), token_mint.key().as_ref()],
        bump = dex_listing.bump,
        constraint = dex_listing.liquidity_locked @ ErrorCode::LiquidityNotLocked,
    )]
    pub dex_listing: Account<'info, DexListing>,

    /// –•—Ä–∞–Ω–∏–ª–∏—â–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö LP —Ç–æ–∫–µ–Ω–æ–≤ (PDA)
    #[account(
        init,
        payer = owner,
        seeds = [b"lp_vault", lp_mint.key().as_ref(), owner.key().as_ref()],
        bump,
        token::mint = lp_mint,
        token::authority = lp_vault,
    )]
    pub lp_vault: Account<'info, TokenAccount>,

    /// –ê–∫–∫–∞—É–Ω—Ç –≤–ª–∞–¥–µ–ª—å—Ü–∞ —Å LP —Ç–æ–∫–µ–Ω–∞–º–∏ (–∏—Å—Ç–æ—á–Ω–∏–∫)
    #[account(
        mut,
        constraint = owner_lp_account.mint == lp_mint.key(),
        constraint = owner_lp_account.owner == owner.key(),
        constraint = owner_lp_account.amount >= lp_amount @ ErrorCode::InsufficientBalance,
    )]
    pub owner_lp_account: Account<'info, TokenAccount>,

    /// –í–ª–∞–¥–µ–ª–µ—Ü LP —Ç–æ–∫–µ–Ω–æ–≤ (—Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–æ–∫–µ–Ω–∞)
    #[account(mut)]
    pub owner: Signer<'info>,

    /// –°–∏—Å—Ç–µ–º–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

/// –ö–æ–Ω—Ç–µ–∫—Å—Ç—ã –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ LP —Ç–æ–∫–µ–Ω–æ–≤
#[derive(Accounts)]
pub struct UnlockLpTokens<'info> {
    /// –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ LP —Ç–æ–∫–µ–Ω–æ–≤
    #[account(
        mut,
        seeds = [LpTokenLock::SEED.as_bytes(), lp_mint.key().as_ref(), owner.key().as_ref()],
        bump = lp_lock.bump,
        constraint = lp_lock.owner == owner.key() @ ErrorCode::Unauthorized,
        constraint = lp_lock.is_locked @ ErrorCode::AlreadyUnlocked,
    )]
    pub lp_lock: Account<'info, LpTokenLock>,

    /// Mint LP —Ç–æ–∫–µ–Ω–æ–≤
    pub lp_mint: Account<'info, Mint>,

    /// –•—Ä–∞–Ω–∏–ª–∏—â–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö LP —Ç–æ–∫–µ–Ω–æ–≤ (PDA)
    #[account(
        mut,
        seeds = [b"lp_vault", lp_mint.key().as_ref(), owner.key().as_ref()],
        bump,
        token::mint = lp_mint,
        token::authority = lp_vault,
    )]
    pub lp_vault: Account<'info, TokenAccount>,

    /// –¶–µ–ª–µ–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è LP —Ç–æ–∫–µ–Ω–æ–≤
    #[account(
        mut,
        constraint = destination_lp_account.mint == lp_mint.key(),
        constraint = destination_lp_account.owner == owner.key(),
    )]
    pub destination_lp_account: Account<'info, TokenAccount>,

    /// –í–ª–∞–¥–µ–ª–µ—Ü LP —Ç–æ–∫–µ–Ω–æ–≤
    #[account(mut)]
    pub owner: Signer<'info>,

    /// –°–∏—Å—Ç–µ–º–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
    pub token_program: Program<'info, Token>,
}

/// –ö–æ–Ω—Ç–µ–∫—Å—Ç—ã –¥–ª—è –ø—Ä–æ–¥–ª–µ–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
#[derive(Accounts)]
pub struct ExtendLock<'info> {
    /// –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ LP —Ç–æ–∫–µ–Ω–æ–≤
    #[account(
        mut,
        seeds = [LpTokenLock::SEED.as_bytes(), lp_mint.key().as_ref(), owner.key().as_ref()],
        bump = lp_lock.bump,
        constraint = lp_lock.owner == owner.key() @ ErrorCode::Unauthorized,
        constraint = lp_lock.is_locked @ ErrorCode::AlreadyUnlocked,
    )]
    pub lp_lock: Account<'info, LpTokenLock>,

    /// Mint LP —Ç–æ–∫–µ–Ω–æ–≤
    pub lp_mint: Account<'info, Mint>,

    /// –í–ª–∞–¥–µ–ª–µ—Ü LP —Ç–æ–∫–µ–Ω–æ–≤
    pub owner: Signer<'info>,
}

/// –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ LP —Ç–æ–∫–µ–Ω–æ–≤ —Å —Ç–∞–π–º–ª–æ–∫–æ–º
pub fn lock_lp_tokens(
    ctx: Context<LockLpTokens>,
    lp_amount: u64,
    lock_duration: i64,
    enable_vesting: bool,
) -> Result<()> {
    msg!("üîí –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ LP —Ç–æ–∫–µ–Ω–æ–≤...");
    msg!("   üí∞ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {}", lp_amount);
    msg!("   ‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {} –¥–Ω–µ–π", lock_duration / 86_400);
    msg!("   üìä Vesting: {}", if enable_vesting { "–í–∫–ª—é—á–µ–Ω" } else { "–í—ã–∫–ª—é—á–µ–Ω" });

    let clock = Clock::get()?;

    // === –í–ê–õ–ò–î–ê–¶–ò–Ø ===

    require!(lp_amount > 0, ErrorCode::InvalidAmount);
    require!(
        lock_duration >= MIN_LOCK_DURATION,
        ErrorCode::LockDurationTooShort
    );
    require!(
        lock_duration <= MAX_LOCK_DURATION,
        ErrorCode::LockDurationTooLong
    );

    // === –ü–ï–†–ï–í–û–î LP –¢–û–ö–ï–ù–û–í –í –•–†–ê–ù–ò–õ–ò–©–ï ===

    msg!("üì¶ –ü–µ—Ä–µ–≤–æ–¥ LP —Ç–æ–∫–µ–Ω–æ–≤ –≤ –∑–∞—â–∏—â–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ...");

    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.owner_lp_account.to_account_info(),
                to: ctx.accounts.lp_vault.to_account_info(),
                authority: ctx.accounts.owner.to_account_info(),
            },
        ),
        lp_amount,
    )?;

    // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–õ–û–ö–ò–†–û–í–ö–ò ===

    let lp_lock = &mut ctx.accounts.lp_lock;
    lp_lock.owner = ctx.accounts.owner.key();
    lp_lock.lp_mint = ctx.accounts.lp_mint.key();
    lp_lock.token_mint = ctx.accounts.token_mint.key();
    lp_lock.lp_vault = ctx.accounts.lp_vault.key();
    lp_lock.locked_amount = lp_amount;
    lp_lock.unlocked_amount = 0;
    lp_lock.lock_start = clock.unix_timestamp;
    lp_lock.lock_end = clock.unix_timestamp
        .checked_add(lock_duration)
        .ok_or(ErrorCode::MathOverflow)?;
    lp_lock.is_locked = true;
    lp_lock.vesting_enabled = enable_vesting;
    lp_lock.last_unlock_time = clock.unix_timestamp;
    lp_lock.bump = ctx.bumps.lp_lock;

    // === –°–û–ë–´–¢–ò–ï –ë–õ–û–ö–ò–†–û–í–ö–ò ===

    emit!(LpTokensLockedEvent {
        owner: ctx.accounts.owner.key(),
        lp_mint: ctx.accounts.lp_mint.key(),
        token_mint: ctx.accounts.token_mint.key(),
        locked_amount: lp_amount,
        lock_start: lp_lock.lock_start,
        lock_end: lp_lock.lock_end,
        vesting_enabled: enable_vesting,
        timestamp: clock.unix_timestamp,
    });

    msg!("‚úÖ LP —Ç–æ–∫–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã!");
    msg!("   üîê Vault: {}", ctx.accounts.lp_vault.key());
    msg!("   üìÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞: {} (Unix timestamp)", lp_lock.lock_end);

    let unlock_date_days = lock_duration / 86_400;
    msg!("   ‚è∞ –ß–µ—Ä–µ–∑ {} –¥–Ω–µ–π", unlock_date_days);

    Ok(())
}

/// –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ LP —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ—Å–ª–µ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Å—Ä–æ–∫–∞
pub fn unlock_lp_tokens(ctx: Context<UnlockLpTokens>, amount: u64) -> Result<()> {
    msg!("üîì –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ LP —Ç–æ–∫–µ–Ω–æ–≤...");
    msg!("   üí∞ –ó–∞–ø—Ä–æ—à–µ–Ω–æ: {}", amount);

    let clock = Clock::get()?;
    let lp_lock = &mut ctx.accounts.lp_lock;

    // === –í–ê–õ–ò–î–ê–¶–ò–Ø ===

    require!(amount > 0, ErrorCode::InvalidAmount);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Å—Ä–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏—Å—Ç–µ–∫
    let current_time = clock.unix_timestamp;

    // === –†–ê–°–ß–ï–¢ –î–û–°–¢–£–ü–ù–û–ì–û –ö–û–õ–ò–ß–ï–°–¢–í–ê ===

    let available_amount = if lp_lock.vesting_enabled {
        // Vesting: –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
        calculate_vested_amount(lp_lock, current_time)?
    } else {
        // –ë–µ–∑ vesting: —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–≥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Å—Ä–æ–∫–∞
        require!(
            current_time >= lp_lock.lock_end,
            ErrorCode::LockPeriodNotExpired
        );
        lp_lock.locked_amount
    };

    msg!("   ‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: {}", available_amount);

    require!(amount <= available_amount, ErrorCode::InsufficientBalance);

    // === –ü–ï–†–ï–í–û–î LP –¢–û–ö–ï–ù–û–í –í–õ–ê–î–ï–õ–¨–¶–£ ===

    msg!("üì§ –ü–µ—Ä–µ–≤–æ–¥ LP —Ç–æ–∫–µ–Ω–æ–≤ –≤–ª–∞–¥–µ–ª—å—Ü—É...");

    let lp_mint_key = ctx.accounts.lp_mint.key();
    let owner_key = ctx.accounts.owner.key();
    let vault_seeds = &[
        b"lp_vault",
        lp_mint_key.as_ref(),
        owner_key.as_ref(),
        &[ctx.bumps.lp_vault],
    ];
    let vault_signer = &[&vault_seeds[..]];

    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.lp_vault.to_account_info(),
                to: ctx.accounts.destination_lp_account.to_account_info(),
                authority: ctx.accounts.lp_vault.to_account_info(),
            },
            vault_signer,
        ),
        amount,
    )?;

    // === –û–ë–ù–û–í–õ–ï–ù–ò–ï –°–û–°–¢–û–Ø–ù–ò–Ø ===

    lp_lock.locked_amount = lp_lock.locked_amount
        .checked_sub(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    lp_lock.unlocked_amount = lp_lock.unlocked_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    lp_lock.last_unlock_time = current_time;

    // –ï—Å–ª–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –≤—Å–µ —Ç–æ–∫–µ–Ω—ã
    if lp_lock.locked_amount == 0 {
        lp_lock.is_locked = false;
        msg!("üéâ –í—Å–µ LP —Ç–æ–∫–µ–Ω—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã!");
    }

    // === –°–û–ë–´–¢–ò–ï –†–ê–ó–ë–õ–û–ö–ò–†–û–í–ö–ò ===

    emit!(LpTokensUnlockedEvent {
        owner: ctx.accounts.owner.key(),
        lp_mint: ctx.accounts.lp_mint.key(),
        unlocked_amount: amount,
        remaining_locked: lp_lock.locked_amount,
        timestamp: current_time,
    });

    msg!("‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!");
    msg!("   üìä –û—Å—Ç–∞–ª–æ—Å—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {}", lp_lock.locked_amount);

    Ok(())
}

/// –ü—Ä–æ–¥–ª–µ–Ω–∏–µ —Å—Ä–æ–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
pub fn extend_lock(ctx: Context<ExtendLock>, additional_duration: i64) -> Result<()> {
    msg!("‚è±Ô∏è –ü—Ä–æ–¥–ª–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ LP —Ç–æ–∫–µ–Ω–æ–≤...");
    msg!("   ‚ûï –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è: {} –¥–Ω–µ–π", additional_duration / 86_400);

    let clock = Clock::get()?;
    let lp_lock = &mut ctx.accounts.lp_lock;

    // === –í–ê–õ–ò–î–ê–¶–ò–Ø ===

    require!(
        additional_duration > 0,
        ErrorCode::InvalidLockDuration
    );

    let new_lock_end = lp_lock.lock_end
        .checked_add(additional_duration)
        .ok_or(ErrorCode::MathOverflow)?;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –Ω–æ–≤—ã–π —Å—Ä–æ–∫ –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º
    let total_duration = new_lock_end - lp_lock.lock_start;
    require!(
        total_duration <= MAX_LOCK_DURATION,
        ErrorCode::LockDurationTooLong
    );

    // === –û–ë–ù–û–í–õ–ï–ù–ò–ï –°–†–û–ö–ê ===

    let old_lock_end = lp_lock.lock_end;
    lp_lock.lock_end = new_lock_end;

    // === –°–û–ë–´–¢–ò–ï –ü–†–û–î–õ–ï–ù–ò–Ø ===

    emit!(LockExtendedEvent {
        owner: ctx.accounts.owner.key(),
        lp_mint: ctx.accounts.lp_mint.key(),
        old_lock_end,
        new_lock_end,
        additional_days: additional_duration / 86_400,
        timestamp: clock.unix_timestamp,
    });

    msg!("‚úÖ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ–¥–ª–µ–Ω–∞!");
    msg!("   üìÖ –°—Ç–∞—Ä—ã–π —Å—Ä–æ–∫: {} (Unix timestamp)", old_lock_end);
    msg!("   üìÖ –ù–æ–≤—ã–π —Å—Ä–æ–∫: {} (Unix timestamp)", new_lock_end);

    Ok(())
}

// === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===

/// –†–∞—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–æ–∫–µ–Ω–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø—Ä–∏ vesting
fn calculate_vested_amount(lp_lock: &LpTokenLock, current_time: i64) -> Result<u64> {
    // –ï—Å–ª–∏ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    if current_time < lp_lock.lock_start {
        return Ok(0);
    }

    // –ï—Å–ª–∏ —Å—Ä–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏—Å—Ç–µ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é
    if current_time >= lp_lock.lock_end {
        return Ok(lp_lock.locked_amount);
    }

    // –õ–∏–Ω–µ–π–Ω—ã–π vesting: unlockable = total * (time_passed / total_duration)
    let time_passed = current_time - lp_lock.lock_start;
    let total_duration = lp_lock.lock_end - lp_lock.lock_start;

    let initial_total = lp_lock.locked_amount
        .checked_add(lp_lock.unlocked_amount)
        .ok_or(ErrorCode::MathOverflow)?;

    let vested_amount = (initial_total as u128)
        .checked_mul(time_passed as u128)
        .ok_or(ErrorCode::MathOverflow)?
        .checked_div(total_duration as u128)
        .ok_or(ErrorCode::MathOverflow)? as u64;

    // –í—ã—á–∏—Ç–∞–µ–º —É–∂–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
    let available = vested_amount
        .checked_sub(lp_lock.unlocked_amount)
        .ok_or(ErrorCode::MathOverflow)?;

    Ok(available)
}

// === –°–û–ë–´–¢–ò–Ø ===

/// –°–æ–±—ã—Ç–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ LP —Ç–æ–∫–µ–Ω–æ–≤
#[event]
pub struct LpTokensLockedEvent {
    pub owner: Pubkey,
    pub lp_mint: Pubkey,
    pub token_mint: Pubkey,
    pub locked_amount: u64,
    pub lock_start: i64,
    pub lock_end: i64,
    pub vesting_enabled: bool,
    pub timestamp: i64,
}

/// –°–æ–±—ã—Ç–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ LP —Ç–æ–∫–µ–Ω–æ–≤
#[event]
pub struct LpTokensUnlockedEvent {
    pub owner: Pubkey,
    pub lp_mint: Pubkey,
    pub unlocked_amount: u64,
    pub remaining_locked: u64,
    pub timestamp: i64,
}

/// –°–æ–±—ã—Ç–∏–µ –ø—Ä–æ–¥–ª–µ–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
#[event]
pub struct LockExtendedEvent {
    pub owner: Pubkey,
    pub lp_mint: Pubkey,
    pub old_lock_end: i64,
    pub new_lock_end: i64,
    pub additional_days: i64,
    pub timestamp: i64,
}
